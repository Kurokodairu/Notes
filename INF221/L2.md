## Proof by induction
We have a proposition for n=1, n=2, n=3.. wich we call P(1), P(2), P(3).
We then prove the proposition first for the base case, usually P(1).
We assume P2, P3, P(n) all hold and prove that P(n+1) also holds under this assumption, thus we have proven the proposition for all n.

![[Pasted image 20260209082309.png]]
![[Pasted image 20260209082322.png]]



## Analysis of time
assess performance theoretically (paper and pencil) and empirically
(benchmarks)![[Pasted image 20260209082927.png]]
- First line is n, because we first initialize and at the end j will be A.length +1 (checks for end)
- $t_j$ will be run only when the if statement is True, so if the left number i is smaller than j it will not run.
- Still have to check the while statement, but might not run the inside (t-1), For [4,3,2,1] - checks while 4 times, orders (in the while loop) 3 times.

#### Best case
- We never enter the while loop: for all
- True if data is already sorted
- Then we have
![[Pasted image 20260209084422.png]]
- Running time here is **linear** in n, $T(n) = O(n)$

#### Worst case
- We have to run through the loop until i == 0 for each j
- True if data is in reverse order
- $t_j$ = j
 ![[Pasted image 20260209084628.png]]
- Running time is quadratic in n, $T(n) = O(n²)$ 

#### Average case
- Assume here: need to run half-way through while-loop
- Quadratic running-time dependence as for worst case, but with A/4 instead of A/2
- So also, $T(n) = O(n²)$


---
## Designing algorithms
### Divide and conquer
- The divide-and-conquer algorithm design can perform the same sorting task (for worst case scenario) in far less time than insertion sort
- Many useful algorithms are recursive
- Recursion in computer science is a method where the solution to a problem depends on solutions to smaller instances of the same problem

1. Divide the problem into a number of subproblems
2. Conquer the subproblems by solving them recursively. If the subproblem sizes are small enough, however, just solve the subproblems in a straightforward manner
3. Combine the solutions to the subproblem into the solution for the original problem.


#### Correctness of Merge(A,p,q,r)
**Invariant**
At the start of each iteration of the for loop of lines 12-18
1. subarray A[p..k - 1] contains the k - p smallest elements of L[1..n1 +1] and R[1..n2 + 1] in sorted order
2. L[i] and R[j] are the smallest elements of their arrays that have not been copied back into A

**Proof**
-  