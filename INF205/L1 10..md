
### **Pointer**
Refrencing &:
pt = &var; -> reference, get the address

Derefrencing \*:
\*pt to dereference -> Get the content

```c++
 int x=5; int* y = &x; cout << x << "is the same as" << *y;
```
\*(&x)  == x


Segfault
minne unenfor ens grenser

pass by value vs pass by reference
verdien eller adressen


## Compilation & Build

```bash
# Single file
g++ myfile.cpp -o myfile

# Separate compile + link
g++ -c file1.cpp          # → file1.o
g++ -c file2.cpp          # → file2.o
g++ -o program *.o        # link → executable

# Or just use make
make myprogram
```

- **Header file** (`.h`) → declarations: `bool is_prime(int n);`
- **Code file** (`.cpp`) → definitions: `bool is_prime(int n) { ... }`
- Compiler runs on `.cpp` files, not `.h` files directly
- Compiler → `.o` object files → Linker → executable

## Static Typing (C++ vs Python)

- C++ is **statically typed** – type must be declared at compile time
- Python is dynamically typed – everything is an object

| Type | Description |
|---|---|
| `int` | signed integer |
| `short`, `long`, `long long` | smaller/larger integer range |
| `unsigned int` | natural numbers only (⚠️ wraparound) |
| `float` | single-precision float |
| `double` | double-precision float |
| `bool` | `false` (0) / `true` (≠0) |
| `char` | ASCII character |

## Functions

```cpp
// declaration
ret_type name(argtype_a a, argtype_b b);

// definition
ret_type name(argtype_a a, argtype_b b) {
    return value; // must match ret_type
}
```

**Overloading** – same name, different parameter types:

```cpp
void do_something(int n) { ... }
void do_something(double x) { ... }
```

## Pointers

- **Pointer** = variable holding a memory address
- `X* p` → pointer to type X
- `&x` → get address of x (referencing)
- `*p` → get value at address p (dereferencing)
- `&` and `*` are inverses: `*(&x) == x`

```cpp
int x = 5;
int* p = &x;     // p holds address of x
*p = 10;          // x is now 10
```

- Set to `nullptr` when no valid address
- Allocate: `int* arr = new int[8]();`
- Deallocate: `delete[] arr;`

## Arrays

- **Static** – fixed size at declaration, contiguous in memory
- Array variable **is a pointer** to first element (`int[]` == `int*`)
- Access `x[i]` → compiler computes `x + sizeof(int) * i`

```cpp
int a[6];                        // uninitialized
int b[] = {4, 2, 3, -7, 2, 3};  // explicit values
int c[6] = {};                   // all zeroes
```

- Python lists = **dynamic** arrays (can grow/shrink, reserve capacity)
- C/C++ arrays = **static** (fixed size after creation)

## Pass by Value vs Reference

| Method | Syntax | Effect |
|---|---|---|
| **By value** | `void f(int y)` | copy created; original unchanged |
| **By pointer** | `void f(int* y)` | pass `&x`; modify via `*y` |
| **By reference** | `void f(int& y)` | pass `x`; modify via `y` directly |

**Pass by value** advantages:
- Safe – original protected from changes
- Memory on call stack, managed by compiler
- More modular code

**Pass by reference** advantages:
- No copy → efficient for large data
- Can modify original variable

**Converting between pointer & reference:**

```cpp
// reference → pointer
int* p = &ref_var;

// pointer → reference
int& r = *ptr_var;
```

**Python comparison:** Python uses "pass by object reference" – the object reference is passed by value (mutating the object affects the original, but reassigning the variable does not).