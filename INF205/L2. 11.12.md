# INF205 – Modern C++ (Quick Reference)

## Programming Paradigms

- **Imperative** – instruction by instruction, `goto` jumps
- **Structured** – higher-level control flow (if/while/for)
- **Procedural** – functions as top-level unit
- **OOP** – classes as top-level unit, objects instantiate classes
- **Functional/Declarative** – describe solution, not steps
- **Generic** – templates; mixes declarative ideas into OOP

## Classes (Python → C++)

- `self` in Python → `this` pointer in C++
- Access member via object: `obj.member`
- Access member via pointer: `ptr->member` (shorthand for `(*ptr).member`)
- `const` method → cannot modify object's properties
- **Properties** = variables, **Methods** = functions, both are **members**

## Public / Private

```cpp
class Example {
public:
  int getX() const { return this->x; }  // getter
  void setX(int v) { this->x = v; }     // setter
  void doWork();
private:
  int x;              // only accessible inside class
  void helper();      // internal-only method
};
```

- Make all properties **private**, expose via **getters/setters**
- Internal helper methods → **private**

## Preconditions & Postconditions

- **Precondition** – state that must hold *before* a unit runs
- **Postcondition** – state guaranteed *after* a unit runs (if precondition was met)
- In **design by contract**, the **caller** guarantees the precondition

## Assertions

```cpp
#include <cassert>
assert(height > 0);        // traditional

// GSL style (C++ Core Guidelines)
Expects(height > 0);       // precondition
Ensures(result > 0);       // postcondition
```

## Namespaces

- Access name `Y` in namespace `X`: `X::Y`
- `using namespace X;` → all names from X available without prefix
- **Unnamed namespace** (`namespace { ... }`) → internal/file-local helpers
- **SF.21:** Don't use unnamed namespace in headers
- **SF.22:** Use unnamed namespace for all non-exported entities

## Function Overloading

- Same function name, different parameter types, **same namespace**
- Different namespaces with same name ≠ overloading (just separate functions)

## Key C++ Core Guidelines

| Rule | Summary |
|---|---|
| F.1 | Name functions meaningfully |
| F.2 | One function = one logical operation |
| F.3 | Keep functions short |
| F.46 | `main()` returns `int` |
| ES.102 | Use **signed** types for arithmetic |
| ES.106 | Don't use `unsigned` to avoid negatives |
| ES.107 | Don't use `unsigned` for array indices |

## ⚠️ Pitfall: Unsigned Arithmetic

```cpp
unsigned int a = 2 - 3; // = 4'294'967'295 (wraps around!)
```

→ Prefer `int` or `long` over `unsigned int`.


# INF205 – Modern C++ & Legacy C/C++ (Quick Reference)

## I/O Operator Overloading

```cpp
// Define out/in methods on your class
void C::out(ostream* target) const { *target << ...; }
void C::in(istream* source) { *source >> ...; }

// Overload << and >>
ostream& operator<<(ostream& str, const C& x) {
    x.out(&str);
    return str;
}
istream& operator>>(istream& str, C& x) {
    x.in(&str);
    return str;
}
```

- Input & output should use the **same serialization** format

## File I/O

```cpp
#include <fstream>
std::ifstream infile(argv[1]);   // read from file
std::ofstream outfile("out.txt"); // write to file
```

- Data must be **serialized** to store in a file

## auto, const, constexpr

| Keyword | Meaning |
|---|---|
| `auto` | compiler deduces type (requires initialization) |
| `const` | immutable after initialization |
| `constexpr` | immutable + evaluated at **compile time** |

```cpp
constexpr int dim = 3;           // known at compile time
const int n_coords = n * dim;    // immutable, runtime value
auto x = 42;                     // compiler deduces int
```

**Core Guidelines:**
- **Con.1:** Make objects immutable by default
- **Con.4:** Use `const` for values that don't change
- **Con.5:** Use `constexpr` for compile-time values

## const with Pointers (Cheat Sheet)

```cpp
const int* p;        // pointer to const int (can't change *p)
int* const p;        // const pointer to int (can't change p)
const int* const p;  // both const
```

**Rules:**
1. Prefer pass by value when possible
2. If passing by reference and not modifying → mark `const`
3. Arrays can **never** be passed by value (they're pointers)

## C++ Standard Template Library (STL)

| Container | Description |
|---|---|
| `vector<T>` | dynamic array (≈ Python list) |
| `deque<T>` | double-ended dynamic array |
| `forward_list<T>` | singly linked list |
| `list<T>` | doubly linked list |
| `set<T>` | unique keys |
| `map<T, V>` | unique key-value pairs |
| `multimap<T, V>` | key-value pairs, duplicate keys ok |
| `array<T, n>` | static array (fixed size n) |

```cpp
std::vector<int> v = {1, 2, 3};
std::map<std::string, int> m;
```

## C-Style Strings

- C string = `char[]` terminated by `'\0'`
- String literal `"INF205"` is type `const char*` (not `std::string`)
- Single quotes → `char`: `'a'`
- Double quotes → C-string: `"abc"`

```cpp
char s[] = "INF205";  // 7 bytes: 6 chars + '\0'
```

- `std::string` **can** be passed by value
- `char[]` (C string) **cannot** be passed by value (it's an array/pointer)

## Legacy C/C++ Still in Use

- Raw arrays (`int[]`) → prefer `std::array` / `std::vector`
- C strings (`char[]`) → still needed for command-line args (`argv`)
- `assert()` → still common
- Preprocessor: `#define`, `#ifdef`, `#ifndef` → can cause opaque code
- `struct` → like `class` but all members **public** by default
- Global variables → generally bad practice (harder debugging/verification)

## Command-Line Arguments

```cpp
int main(int argc, char* argv[]) {
    // argc = number of arguments
    // argv[0] = program name
    // argv[1] = first argument (as C string)
}
```

## Scope & Lifetime

- **Scope** = where a variable name is valid in source code
- **Global variable** = accessible everywhere (avoid when possible)
- Local variables live on the **call stack**, destroyed when function returns
- Heap-allocated (`new`) lives until `delete` is called