## Key Terminology

| English | Norwegian |
|---|---|
| Allocation | Allokering |
| Deallocation | Deallokering |
| Call stack | Kallstakk |
| Stack frame | Stakkramme |
| Heap | Haug |
| Garbage collection | Søppeltømming |

---

## Stack vs Heap

| | **Stack** | **Heap** |
|---|---|---|
| **Managed by** | Compiler (automatic) | Programmer (manual) |
| **Allocation** | On function call | `new` |
| **Deallocation** | On function return | `delete` / `delete[]` |
| **Lifetime** | Limited to function scope | Until explicitly freed |
| **Garbage collection** | N/A | **None in C++!** |

---

## Pointers — Quick Reference

```cpp
// Declare
int* p;

// Initialize
int* p = nullptr;            // null pointer
int* p = &some_variable;     // address of stack variable
int* p = new int(42);        // heap allocation, *p == 42

// Deallocate
delete p;                    // free heap memory
```

---

## Arrays — Quick Reference

```cpp
// Stack allocation
int vals[6];                       // uninitialized
int vals[] = {4, 2, 3, -7, 2, 3}; // explicit values
int vals[6] = {};                  // all zeroes

// Heap allocation
int* vals = new int[6]();          // zero-initialized

// Heap deallocation
delete[] vals;   // ⚠️ use delete[], NOT delete
```

> **Pitfall:** `delete vals` only frees `vals[0]`. Always use `delete[]` for arrays.

---

## What if `new` fails? (not enough memory)

```cpp
new VeryBigObject;                    // throws exception
new(std::nothrow) VeryBigObject;      // returns nullptr
```

---

## Stack Frames

- Each function call pushes a **stack frame** containing its parameters + local variables.
- When the function returns, the frame is popped — locals are destroyed.
- Inspectable with `gdb`:

```bash
g++ -g3 -o prog prog.cpp
gdb prog
# inside gdb:
# break main
# run
# bt          (backtrace — shows all stack frames)
```

---

## Fast Copying

```cpp
// ❌ Slow element-wise loop
for(size_t i = 0; i < n; i++) target[i] = source[start + i];

// ✅ C-style (raw arrays only)
#include <cstring>
std::memcpy(target, source + start, n * sizeof(element_type));

// ✅ Modern C++ (works with STL containers too)
#include <algorithm>
std::copy(source + start, source + start + n, target);
```

---

## Golden Rules

1. Every `new` needs a matching `delete`; every `new[]` needs `delete[]`.
2. Never `delete` a stack variable.
3. No garbage collection in C++ — **you** are responsible.
4. Prefer `std::copy` over manual loops for bulk copying.